import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { UserService } from '../users/user.service';
import {
  DumpService,
  CreateDumpRequest,
  DumpProcessingResult,
} from '../dumps/services/dump.service';
import { HelpCommand } from './commands/help.command';
import { RecentCommand } from './commands/recent.command';
import { UpcomingCommand } from './commands/upcoming.command';
import { TrackCommand } from './commands/track.command';
import { SearchCommand } from './commands/search.command';
import { ReportCommand } from './commands/report.command';
import { ResponseFormatterService } from '../ai/formatter.service';
import { MetricsService } from '../metrics/metrics.service';
import { FeatureType } from '../../entities/feature-usage.entity';
import { EntityExtractionResult } from '../ai/extraction.service';
import { ContentAnalysisResponse } from '../ai/claude.service';

export interface WhatsAppMessage {
  id: string;
  from: string;
  timestamp: string;
  type: 'text' | 'image' | 'audio' | 'voice' | 'video' | 'document' | 'sticker' | 'location' | 'contacts';
  text?: {
    body: string;
  };
  image?: {
    id: string;
    mime_type: string;
    sha256: string;
    caption?: string;
  };
  audio?: {
    id: string;
    mime_type: string;
    sha256: string;
  };
  voice?: {
    id: string;
    mime_type: string;
    sha256: string;
  };
  video?: {
    id: string;
    mime_type: string;
    sha256: string;
    caption?: string;
  };
  document?: {
    id: string;
    filename: string;
    mime_type: string;
    sha256: string;
    caption?: string;
  };
  sticker?: {
    id: string;
    mime_type: string;
    sha256: string;
  };
  location?: {
    latitude: number;
    longitude: number;
    name?: string;
    address?: string;
  };
  contacts?: Array<{
    name: {
      formatted_name: string;
      first_name?: string;
    };
    phones?: Array<{
      phone: string;
      type?: string;
    }>;
  }>;
}

export interface WhatsAppContact {
  profile: {
    name: string;
  };
  wa_id: string;
}

export interface WhatsAppWebhookPayload {
  object: string;
  entry: Array<{
    id: string;
    changes: Array<{
      value: {
        messaging_product: string;
        metadata: {
          display_phone_number: string;
          phone_number_id: string;
        };
        contacts?: WhatsAppContact[];
        messages?: WhatsAppMessage[];
        statuses?: Array<{
          id: string;
          status: string;
          timestamp: string;
          recipient_id: string;
        }>;
      };
      field: string;
    }>;
  }>;
}

export interface WhatsAppSendMessageRequest {
  messaging_product: 'whatsapp';
  to: string;
  type: 'text' | 'template';
  text?: {
    body: string;
  };
  template?: {
    name: string;
    language: {
      code: string;
    };
    components?: Array<{
      type: string;
      parameters: Array<{
        type: string;
        text: string;
      }>;
    }>;
  };
}

export interface WhatsAppMediaResponse {
  id: string;
  url?: string;
  mime_type?: string;
  sha256?: string;
  file_size?: number;
}

@Injectable()
export class WhatsAppService {
  private readonly logger = new Logger(WhatsAppService.name);
  private readonly authToken: string;
  private readonly accountSid: string;
  private readonly phoneNumber: string;
  private readonly apiUrl: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly userService: UserService,
    private readonly dumpService: DumpService,
    private readonly helpCommand: HelpCommand,
    private readonly recentCommand: RecentCommand,
    private readonly upcomingCommand: UpcomingCommand,
    private readonly trackCommand: TrackCommand,
    private readonly searchCommand: SearchCommand,
    private readonly reportCommand: ReportCommand,
    private readonly responseFormatterService: ResponseFormatterService,
    private readonly metricsService: MetricsService,
  ) {
    // Meta WhatsApp API Configuration
    this.authToken =
      this.configService.get<string>('WHATSAPP_ACCESS_TOKEN') || '';
    this.accountSid =
      this.configService.get<string>('WHATSAPP_PHONE_NUMBER_ID') || '';
    this.phoneNumber =
      this.configService.get<string>('WHATSAPP_PHONE_NUMBER') || '';
    this.apiUrl = `https://graph.facebook.com/v21.0/${this.accountSid}`;

    if (!this.authToken || !this.accountSid) {
      this.logger.warn('WhatsApp Meta API credentials not fully configured');
    }
  }

  async sendMessage(
    request: WhatsAppSendMessageRequest,
  ): Promise<{ id: string }> {
    this.logger.log(`Sending WhatsApp message to ${request.to}`);

    // Clean phone number (remove all non-digits)
    const toNumber = request.to.replace(/\D/g, '');

    // Build Meta API request
    const metaRequest: any = {
      messaging_product: 'whatsapp',
      recipient_type: 'individual',
      to: toNumber,
      type: request.type,
    };

    // Add type-specific content
    if (request.type === 'text' && request.text) {
      metaRequest.text = {
        preview_url: false,
        body: request.text.body,
      };
    } else if (request.type === 'template' && request.template) {
      metaRequest.template = request.template;
    }

    const response = await fetch(`${this.apiUrl}/messages`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${this.authToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(metaRequest),
    });

    if (!response.ok) {
      const error = await response.json();
      this.logger.error(`Failed to send WhatsApp message:`, error);
      throw new Error(
        `Meta WhatsApp API error: ${response.status} ${JSON.stringify(error)}`,
      );
    }

    const data = (await response.json()) as { messages: Array<{ id: string }> };
    return { id: data.messages[0].id };
  }

  async sendTextMessage(to: string, text: string): Promise<{ id: string }> {
    return this.sendMessage({
      messaging_product: 'whatsapp',
      to,
      type: 'text',
      text: {
        body: text,
      },
    });
  }

  async sendFormattedResponse(
    userId: string,
    to: string,
    result: DumpProcessingResult,
    replyToMessageId?: string,
  ): Promise<string> {
    // Extract analysis and entities from the dump
    const dump = result.dump;
    const extractedEntities = dump.extracted_entities || {};

    // Build ContentAnalysisResponse from dump data
    const analysis: ContentAnalysisResponse = {
      summary: dump.ai_summary || '',
      category: dump.category?.name || 'General',
      categoryConfidence: (dump.ai_confidence || 95) / 100,
      extractedEntities: {
        dates: extractedEntities.entities?.dates || [],
        times: extractedEntities.entities?.times || [],
        locations: extractedEntities.entities?.locations || [],
        people: extractedEntities.entities?.people || [],
        organizations: extractedEntities.entities?.organizations || [],
        amounts: extractedEntities.entities?.amounts || [],
        tags: [],
      },
      actionItems: extractedEntities.actionItems || [],
      sentiment:
        (extractedEntities.sentiment as 'positive' | 'neutral' | 'negative') ||
        'neutral',
      urgency:
        (extractedEntities.urgency as 'low' | 'medium' | 'high') || 'low',
      confidence: (dump.ai_confidence || 95) / 100,
    };

    // Build EntityExtractionResult from dump data
    const entities: EntityExtractionResult = {
      entities: (extractedEntities.entityDetails || []).map((entity: any) => ({
        type: entity.type as
          | 'date'
          | 'time'
          | 'location'
          | 'person'
          | 'organization'
          | 'amount'
          | 'phone'
          | 'email'
          | 'url',
        value: entity.value,
        confidence: entity.confidence,
        context: entity.context,
        position: entity.position,
      })),
      summary: extractedEntities.entitySummary || {
        totalEntities: 0,
        entitiesByType: {},
        averageConfidence: 0,
      },
      structuredData: {
        dates: extractedEntities.entities?.dates || [],
        times: extractedEntities.entities?.times || [],
        locations: extractedEntities.entities?.locations || [],
        people: extractedEntities.entities?.people || [],
        organizations: extractedEntities.entities?.organizations || [],
        amounts: extractedEntities.entities?.amounts || [],
        contacts: extractedEntities.entities?.contacts || {
          phones: [],
          emails: [],
          urls: [],
        },
      },
    };

    // Use ResponseFormatterService with brief format
    const formatted =
      await this.responseFormatterService.formatAnalysisResponse(
        userId,
        analysis,
        entities,
        {
          platform: 'whatsapp',
          format: 'brief',
          includeEmojis: true,
          includeMarkdown: false, // WhatsApp uses basic markdown
        },
      );

    // WhatsApp doesn't support HTML, use plain text
    const messageText =
      formatted.text || formatted.html || 'Content processed successfully';

    const response = await this.sendTextMessage(to, messageText);
    return response.id;
  }

  async getMedia(mediaId: string): Promise<WhatsAppMediaResponse> {
    this.logger.log(`Getting media info for ${mediaId}`);

    // Step 1: Get media URL from Meta API using media ID
    const response = await fetch(
      `https://graph.facebook.com/v21.0/${mediaId}`,
      {
        headers: {
          Authorization: `Bearer ${this.authToken}`,
        },
      },
    );

    if (!response.ok) {
      const error = await response.json();
      this.logger.error(`Failed to get WhatsApp media:`, error);
      throw new Error(
        `Meta WhatsApp API error: ${response.status} ${JSON.stringify(error)}`,
      );
    }

    const data = (await response.json()) as WhatsAppMediaResponse;
    return data;
  }

  async downloadMedia(mediaId: string): Promise<Buffer> {
    this.logger.log(`Downloading media with ID ${mediaId}`);

    // Step 1: Get media URL
    const mediaInfo = await this.getMedia(mediaId);

    if (!mediaInfo.url) {
      throw new Error('Media URL not found');
    }

    // Step 2: Download media from temporary URL
    const response = await fetch(mediaInfo.url, {
      headers: {
        Authorization: `Bearer ${this.authToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to download media: ${response.status}`);
    }

    const arrayBuffer = await response.arrayBuffer();
    return Buffer.from(arrayBuffer);
  }

  /**
   * Process Meta API webhook - called from controller
   */
  async processMetaWebhook(
    message: WhatsAppMessage,
    contact?: WhatsAppContact,
  ): Promise<void> {
    try {
      const phoneNumber = message.from;
      this.logger.log(`Processing message from ${phoneNumber}`);

      // Skip processing for test phone numbers
      if (phoneNumber.includes('1234567890') || phoneNumber.includes('test')) {
        this.logger.log(
          'Test message detected - skipping user lookup and response',
        );
        return;
      }

      // Find user by WhatsApp chat ID
      const user = await this.userService.findByChatId(phoneNumber, 'whatsapp');

      if (!user) {
        // This should not happen as webhook controller handles registration
        // But keeping as safety fallback
        this.logger.warn(
          `User not found for WhatsApp number ${phoneNumber} - skipping message processing`,
        );
        return;
      }

      // Handle different message types
      switch (message.type) {
        case 'text':
          await this.handleTextMessage(message, user.id);
          break;
        case 'audio':
        case 'voice':
          await this.handleAudioMessage(message, user.id);
          break;
        case 'image':
          await this.handleImageMessage(message, user.id);
          break;
        case 'document':
          await this.handleDocumentMessage(message, user.id);
          break;
        default:
          await this.sendTextMessage(
            phoneNumber,
            "‚ö†Ô∏è Sorry, I don't support this message type yet. Please send text, voice, photos, or documents.",
          );
      }
    } catch (error) {
      this.logger.error('Error processing WhatsApp message:', error);

      await this.sendTextMessage(
        message.from,
        '‚ùå Sorry, something went wrong. Please try again later.',
      );
    }
  }

  private async handleTextMessage(
    message: WhatsAppMessage,
    userId: string,
  ): Promise<void> {
    const phoneNumber = message.from;
    const text = message.text?.body || '';
    const isTestMode =
      process.env.NODE_ENV === 'development' ||
      process.env.WHATSAPP_TEST_MODE === 'true';

    this.logger.log(`Handling text message: "${text.substring(0, 50)}..."`);

    // Handle bot commands
    if (
      text.startsWith('/') ||
      text.toLowerCase().includes('help') ||
      text.toLowerCase().includes('start') ||
      text.toLowerCase().includes('more') ||
      text.toLowerCase().includes('recent') ||
      text.toLowerCase().includes('report') ||
      text.toLowerCase().includes('search')
    ) {
      await this.handleCommand(text, phoneNumber, userId);
      return;
    }

    try {
      // Create dump request for enhanced processing
      const dumpRequest: CreateDumpRequest = {
        userId,
        content: text,
        contentType: 'text',
        metadata: {
          source: 'whatsapp',
          messageId: message.id,
          chatId: phoneNumber,
        },
      };

      // Process with enhanced ContentRouterService integration
      const result = await this.dumpService.createDumpEnhanced(dumpRequest);

      this.logger.log(
        `‚úÖ Message processed successfully: ${result.dump.ai_summary}`,
      );
      this.logger.log(
        `üìä Analysis: Category=${result.dump.category?.name}, Confidence=${result.dump.ai_confidence}%`,
      );

      if (isTestMode) {
        this.logger.log(
          'TEST MODE: Would send formatted response - simulating success',
        );
        return;
      }

      // Send success response with processing details
      await this.sendFormattedResponse(userId, phoneNumber, result);
    } catch (error) {
      this.logger.error('Error processing text message:', error);

      if (isTestMode) {
        this.logger.log(
          'TEST MODE: Would send error message - simulating error handling',
        );
        return;
      }

      await this.sendTextMessage(
        phoneNumber,
        '‚ùå Sorry, something went wrong while processing your message. Please try again later.',
      );
    }
  }

  private async handleAudioMessage(
    message: WhatsAppMessage,
    userId: string,
  ): Promise<void> {
    const phoneNumber = message.from;
    const audio = message.audio || message.voice;

    if (!audio) {
      await this.sendTextMessage(
        phoneNumber,
        '‚ùå Failed to process audio message.',
      );
      return;
    }

    this.logger.log(`Handling audio message: ${audio.id}`);

    try {
      // For Meta API, audio.id is the media ID - need to download it
      const audioBuffer = await this.downloadMedia(audio.id);

      // Create dump request for enhanced voice processing
      const dumpRequest: CreateDumpRequest = {
        userId,
        content: 'Voice message',
        contentType: 'voice',
        metadata: {
          source: 'whatsapp',
          messageId: message.id,
          chatId: phoneNumber,
          mimeType: audio.mime_type || 'audio/ogg',
        },
        mediaBuffer: audioBuffer,
      };

      // Process with enhanced ContentRouterService integration
      const result = await this.dumpService.createDumpEnhanced(dumpRequest);

      // Send success response with processing details
      await this.sendFormattedResponse(userId, phoneNumber, result);
    } catch (error) {
      this.logger.error('Error handling audio message:', error);
      await this.sendTextMessage(
        phoneNumber,
        '‚ùå Failed to process audio message.',
      );
    }
  }

  private async handleImageMessage(
    message: WhatsAppMessage,
    userId: string,
  ): Promise<void> {
    const phoneNumber = message.from;
    const image = message.image;

    if (!image) {
      await this.sendTextMessage(phoneNumber, '‚ùå Failed to process image.');
      return;
    }

    this.logger.log(`Handling image message: ${image.id}`);

    try {
      // For Meta API, image.id is the media ID - need to download it
      const imageBuffer = await this.downloadMedia(image.id);

      // Create dump request for enhanced image processing
      const dumpRequest: CreateDumpRequest = {
        userId,
        content: image.caption || 'Image',
        contentType: 'image',
        originalText: image.caption,
        metadata: {
          source: 'whatsapp',
          messageId: message.id,
          chatId: phoneNumber,
          mimeType: image.mime_type || 'image/jpeg',
        },
        mediaBuffer: imageBuffer,
      };

      // Process with enhanced ContentRouterService integration
      const result = await this.dumpService.createDumpEnhanced(dumpRequest);

      // Send success response with processing details
      await this.sendFormattedResponse(userId, phoneNumber, result);
    } catch (error) {
      this.logger.error('Error handling image message:', error);
      await this.sendTextMessage(phoneNumber, '‚ùå Failed to process image.');
    }
  }

  private async handleDocumentMessage(
    message: WhatsAppMessage,
    userId: string,
  ): Promise<void> {
    const phoneNumber = message.from;
    const document = message.document;

    if (!document) {
      await this.sendTextMessage(phoneNumber, '‚ùå Failed to process document.');
      return;
    }

    this.logger.log(`Handling document message: ${document.id}`);

    try {
      // For Meta API, document.id is the media ID - need to download it
      const documentBuffer = await this.downloadMedia(document.id);

      // Create dump request for enhanced document processing
      const dumpRequest: CreateDumpRequest = {
        userId,
        content: document.caption || document.filename || 'Document',
        contentType: 'document',
        originalText: document.caption,
        metadata: {
          source: 'whatsapp',
          messageId: message.id,
          chatId: phoneNumber,
          fileName: document.filename,
          mimeType: document.mime_type,
        },
        mediaBuffer: documentBuffer,
      };

      // Process with enhanced ContentRouterService integration
      const result = await this.dumpService.createDumpEnhanced(dumpRequest);

      // Send success response with processing details
      await this.sendFormattedResponse(userId, phoneNumber, result);
    } catch (error) {
      this.logger.error('Error handling document message:', error);
      await this.sendTextMessage(phoneNumber, '‚ùå Failed to process document.');
    }
  }

  private trackBotCommand(command: string, userId: string): void {
    this.metricsService.fireAndForget(() =>
      this.metricsService.trackFeature({
        featureType: FeatureType.BOT_COMMAND,
        detail: command,
        userId,
        metadata: {
          platform: 'whatsapp',
        },
      }),
    );
  }

  private async handleCommand(
    command: string,
    phoneNumber: string,
    userId: string,
  ): Promise<void> {
    // Remove common command prefixes and normalize
    const normalizedCommand = command
      .toLowerCase()
      .trim()
      .replace(/^[/!#@]/, ''); // Remove leading /, !, #, or @

    const [cmd] = normalizedCommand.split(' ');

    // Track bot command usage
    this.trackBotCommand(cmd, userId);

    // Get the user entity for command handlers
    const user = await this.userService.findOne(userId);
    if (!user) {
      await this.sendTextMessage(
        phoneNumber,
        '‚ùå User not found. Please restart by sending "start"',
      );
      return;
    }

    try {
      switch (cmd) {
        case 'start':
        case 'hello':
        case 'hi': {
          await this.sendTextMessage(
            phoneNumber,
            'üëã Welcome to Clutter.AI!\n\n' +
              'I help you capture and organize any content you send me.\n\n' +
              'Send me:\n' +
              'üìù Text messages\n' +
              'üé§ Voice messages\n' +
              'üì∑ Photos\n' +
              'üìÑ Documents\n\n' +
              'Type "help" for more commands.',
          );
          break;
        }

        case 'help': {
          const helpMessage = this.helpCommand.execute('whatsapp');
          await this.sendTextMessage(phoneNumber, helpMessage);
          break;
        }

        case 'recent': {
          const recentMessage = await this.recentCommand.execute(
            user,
            5,
            'whatsapp',
          );
          await this.sendTextMessage(phoneNumber, recentMessage);
          break;
        }

        case 'upcoming':
        case 'next': {
          // Parse optional hours parameter: upcoming 48
          const parts = command.split(' ');
          const hours =
            parts.length > 1 ? Number.parseInt(parts[1], 10) || 24 : 24;
          const upcomingMessage = await this.upcomingCommand.execute(
            user,
            hours,
            'whatsapp',
          );
          await this.sendTextMessage(phoneNumber, upcomingMessage);
          break;
        }

        case 'track': {
          // Parse tracking command: track <tracking-number> OR track list
          const parts = command.split(' ').filter((p) => p.trim());
          const args = parts.slice(1); // Remove 'track' itself
          const trackMessage = await this.trackCommand.execute(
            user,
            args,
            'whatsapp',
          );
          await this.sendTextMessage(phoneNumber, trackMessage);
          break;
        }

        case 'search': {
          const searchMessage = await this.searchCommand.execute(
            user,
            command,
            'whatsapp',
          );
          await this.sendTextMessage(phoneNumber, searchMessage);
          break;
        }

        case 'report': {
          const reportMessage = await this.reportCommand.execute(
            user,
            command,
            'whatsapp',
          );
          await this.sendTextMessage(phoneNumber, reportMessage);
          break;
        }

        default: {
          await this.sendTextMessage(
            phoneNumber,
            '‚ùì I didn\'t understand that command. Send "help" to see available commands.',
          );
        }
      }
    } catch (error) {
      this.logger.error(`Error executing command ${cmd}:`, error);
      await this.sendTextMessage(
        phoneNumber,
        '‚ùå Sorry, something went wrong executing that command. Please try again.',
      );
    }
  }

  /**
   * Convert HTML formatting to WhatsApp markdown
   * Telegram uses HTML tags, WhatsApp uses markdown-like syntax
   */
  private convertHtmlToWhatsApp(text: string): string {
    return text
      .replaceAll(/<b>(.*?)<\/b>/g, '*$1*') // Bold
      .replaceAll(/<i>(.*?)<\/i>/g, '_$1_') // Italic
      .replaceAll(/<code>(.*?)<\/code>/g, '```$1```') // Code
      .replaceAll(/<pre>(.*?)<\/pre>/g, '```$1```') // Preformatted
      .replaceAll(/<[^>]*>/g, ''); // Remove any remaining HTML tags
  }

  /**
   * Auto-register a WhatsApp user using their phone number from Meta API webhook
   * Phone number comes in clean format (no prefix, just digits)
   */
  async autoRegisterUser(
    phoneNumber: string,
    contact?: WhatsAppContact,
  ): Promise<void> {
    try {
      const userName = contact?.profile?.name || 'there';
      this.logger.log(`Linking WhatsApp user: ${phoneNumber} (${userName})`);

      // Format phone number with + prefix for user lookup
      const formattedPhone = phoneNumber.startsWith('+')
        ? phoneNumber
        : `+${phoneNumber}`;

      // Check if user exists with this phone number
      const existingUser = await this.userService.findByPhone(formattedPhone);

      if (existingUser) {
        // Link existing user to WhatsApp chat ID (store clean format)
        await this.userService.update(existingUser.id, {
          chat_id_whatsapp: phoneNumber,
        });

        await this.sendTextMessage(
          phoneNumber,
          `‚úÖ Welcome ${userName}! Your account has been linked to WhatsApp.\n\n` +
            `You can now send me:\n` +
            `üìù Text messages to save thoughts\n` +
            `üé§ Voice messages\n` +
            `üì∏ Photos\n` +
            `üìÑ Documents\n\n` +
            `Try sending: "Preciso lembrar de comprar leite hoje"`,
        );

        this.logger.log(
          `Linked existing user ${existingUser.id} to WhatsApp: ${phoneNumber}`,
        );
      } else {
        // User not found - they need to register first
        await this.sendTextMessage(
          phoneNumber,
          `‚ùå No account found with phone number ${formattedPhone}.\n\n` +
            `Please register first at:\nhttps://theclutter.app\n\n` +
            `After registration, send a message here to link your account.`,
        );

        this.logger.log(
          `Phone number ${formattedPhone} not found, user needs to register at website`,
        );
      }
    } catch (error) {
      this.logger.error('Error during auto-registration:', error);
      await this.sendTextMessage(
        phoneNumber,
        '‚ùå Sorry, there was an error. Please try again or contact support.',
      );
      throw error;
    }
  }

}
